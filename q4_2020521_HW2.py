# -*- coding: utf-8 -*-
"""Q4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/182sIk4_2c4NYmenQH1_iMvn7vbU9b6_y
"""

!pip install opencv-python

"""# import libraries"""

import cv2 as cv
import numpy as np
import os
import glob
from google.colab.patches import cv2_imshow

"""# mount google drive"""

from google.colab import drive
drive.mount('/content/drive')

# Path to the directory
images_path = '/content/drive/My Drive/chess_board_pics/*.jpg'

images = glob.glob(images_path)

len(images)

"""# fill the object list and image list."""

# Arrays to store object points and image points from all the images.
objpoints = [] # 3d point in real world space
imgpoints = [] # 2d points in image plane.

# prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)
square_side = 4.6 # cm
objp = np.zeros((7*7,3), np.float32)
objp[:,:2] = np.mgrid[0:7,0:7].T.reshape(-1,2) * square_side
objp

for fname in images:
  img = cv.imread(fname)
  gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
  # Find the chess board corners
  ret, corners = cv.findChessboardCorners(gray, (7,7), None)

  # If found, add object points, image points (after refining them)
  if ret == True:
    objpoints.append(objp)
    imgpoints.append(corners)

# Draw and display the corners
cv.drawChessboardCorners(img, (7,7), corners, ret)
cv2_imshow(img)
cv.waitKey(500)

cv.destroyAllWindows()

import numpy as np
import cv2 as cv

# Termination criteria for corner refinement
criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)

# Iterate over the images
for fname in images:
    img = cv.imread(fname)
    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)

    # Find the chessboard corners
    ret, corners = cv.findChessboardCorners(gray, (7, 7), None)

    # If chessboard corners are found, refine them
    if ret == True:
        objpoints.append(objp)

        # Refine corner positions for better accuracy
        corners_refined = cv.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)
        imgpoints.append(corners_refined)

        # Draw and display the refined corners
        img_with_corners = img.copy()
        cv.drawChessboardCorners(img_with_corners, (7, 7), corners_refined, ret)
        cv2_imshow(img_with_corners)
        cv.waitKey(500)

# Close all OpenCV windows
cv.destroyAllWindows()

len(imgpoints), len(objpoints)

"""# calibration"""

# termination criteria
criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 1000, 0.001)
# camera calibration
ret, mtx, dist, rvecs, tvecs = cv.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None, criteria = criteria)

mean_error = 0
for i in range(len(objpoints)):
    imgpoints_reprojected, _ = cv.projectPoints(objpoints[i], rvecs[i], tvecs[i], mtx, dist)
    error = cv.norm(imgpoints[i], imgpoints_reprojected, cv.NORM_L2) / len(imgpoints_reprojected)
    mean_error += error

# Print accuracy (mean reprojection error)
print("Mean Reprojection Error: ", mean_error / len(objpoints))

"""# 1 = intrisic parameters"""

print("Estimated camera matrix (Intrinsic parameters):")
print(mtx)

# Extract focal length (fx, fy), skew (s), and principal point (cx, cy)
fx = mtx[0, 0]
fy = mtx[1, 1]
s = mtx[0, 1]
cx = mtx[0, 2]
cy = mtx[1, 2]

# Compute and report reprojection error
mean_error = 0
for i in range(len(objpoints)):
    imgpoints_reprojected, _ = cv.projectPoints(
        objpoints[i], rvecs[i], tvecs[i], mtx, dist
    )
    error = cv.norm(imgpoints[i], imgpoints_reprojected, cv.NORM_L2) / len(imgpoints_reprojected)
    mean_error += error

print("\nReprojection error: ", mean_error / len(objpoints))

print("\nFocal Length (fx, fy):", fx, fy)
print("Skew Parameter (s):", s)
print("Principal Point (cx, cy):", cx, cy)

"""# 2 = Extrinsic Parameters"""

# Report estimated extrinsic camera parameters (rotation matrix and translation vector)
for i in range(len(rvecs)):
    print(f"Image {i+1}:")
    print("Rotation Vector (rvec):", rvecs[i])
    print("Translation Vector (tvec):", tvecs[i])
    print()

"""# 3 = Radial Distortion"""

dist

# Load five raw images for demonstration
raw_images = images[:5]  # Change this path to match your raw image directory

# Undistort the images using the radial distortion coefficients
undistorted_images = []
for img_path in raw_images:
    img = cv.imread(img_path)
    h, w = img.shape[:2]
    new_mtx, roi = cv.getOptimalNewCameraMatrix(mtx, dist, (w, h), 1, (w, h))
    undistorted_img = cv.undistort(img, mtx, dist, None, new_mtx)
    undistorted_images.append(undistorted_img)

# Display original and undistorted images side by side
for i in range(len(raw_images)):
    original_img = cv.imread(raw_images[i])
    undistorted_img = undistorted_images[i]

    # Concatenate images horizontally
    comparison_img = np.hstack((original_img, undistorted_img))

    # Display comparison
    print(f'Image {i+1}: Original vs Undistorted')
    cv2_imshow(comparison_img)
    cv.waitKey(0)

cv.destroyAllWindows()

"""# 4 = Reprojection Error"""

import matplotlib.pyplot as plt
import cv2

# Function to compute re-projection error
def compute_reprojection_error(object_points, image_points, mtx, dist, rvecs, tvecs):
    errors = []
    for i in range(len(object_points)):
        img_points_reprojected, _ = cv2.projectPoints(object_points[i], rvecs[i], tvecs[i], mtx, dist)
        error = cv2.norm(image_points[i], img_points_reprojected, cv2.NORM_L2) / len(img_points_reprojected)
        errors.append(error)
    return errors

# Compute re-projection error for each image
reprojection_errors = compute_reprojection_error(objpoints, imgpoints, mtx, dist, rvecs, tvecs)

mean_error = np.mean(reprojection_errors)
std_deviation = np.std(reprojection_errors)

plt.figure(figsize=(10, 6))
plt.bar(range(len(reprojection_errors)), reprojection_errors)
plt.xlabel('Image Index')
plt.ylabel('Re-projection Error')
plt.title('Re-projection Error for Selected Images')
plt.grid(True)
plt.show()

print("Mean Re-projection Error:", mean_error)
print("Standard Deviation of Re-projection Error:", std_deviation)

"""# 5 = Corner Detection"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def compute_reprojection_error(object_points, image_points, mtx, dist, rvecs, tvecs):
    errors = []
    for i in range(len(object_points)):
        img_points_reprojected, _ = cv2.projectPoints(object_points[i], rvecs[i], tvecs[i], mtx, dist)
        error = cv2.norm(image_points[i], img_points_reprojected, cv2.NORM_L2) / len(img_points_reprojected)
        errors.append(error)
    return errors

# Function to plot original image with detected corners and re-projected corners
def plot_corners(image_path, object_points, image_points, mtx, dist, rvecs, tvecs):
    img = cv2.imread(image_path)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    ret, corners = cv2.findChessboardCorners(gray, (7, 6), None)

    if ret:
        corners2 = cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)

        img_points_reprojected, _ = cv2.projectPoints(object_points, rvecs, tvecs, mtx, dist)

        img_with_corners = cv2.drawChessboardCorners(img.copy(), (7, 6), corners2, ret)

        for point in img_points_reprojected.squeeze():
            center = tuple(map(int, point))  # Convert coordinates to integers
            cv2.circle(img_with_corners, center, 5, (0, 255, 0), -1)

        # Display the image
        plt.imshow(cv2.cvtColor(img_with_corners, cv2.COLOR_BGR2RGB))
        plt.title('Image with Detected and Re-projected Corners')
        plt.axis('off')
        plt.show()


# Plot figures for all 25 images
for i, image_path in enumerate(images):
  if i < len(imgpoints):
    print(f"Plotting image {i+1}")
    plot_corners(image_path, objpoints[i], imgpoints[i], mtx, dist, rvecs[i], tvecs[i])

"""# 6 = Plane Normals"""

import numpy as np

# Function to compute checkerboard plane normals
def compute_plane_normals(objpoints, rvecs, tvecs):
    plane_normals = []
    for i in range(len(objpoints)):
        # Get rotation matrix from rotation vector
        R, _ = cv.Rodrigues(rvecs[i])

        # Transform world coordinates to camera coordinates
        objpoints_cam = np.dot(R, objpoints[i].T) + tvecs[i]

        # Compute plane normals
        normal = np.array([0, 0, 1])  # Normal of XY plane in world coordinates
        normal_cam = np.dot(R, normal)  # Transform normal to camera coordinates
        plane_normals.append(normal_cam)
    return plane_normals

# Call the function to compute plane normals
plane_normals = compute_plane_normals(objpoints, rvecs, tvecs)

# Print or use the computed plane normals as needed
for i, normal in enumerate(plane_normals):
    print(f"Image {i+1} - Checkerboard Plane Normal: {normal}")